{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { dequal } from \"./dequal.js\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect.js\";\nexport function useWidget(_ref) {\n  var widget = _ref.widget,\n      parentIndex = _ref.parentIndex,\n      props = _ref.props,\n      shouldSsr = _ref.shouldSsr;\n  var prevPropsRef = useRef(props);\n  useEffect(function () {\n    prevPropsRef.current = props;\n  }, [props]);\n  var prevWidgetRef = useRef(widget);\n  useEffect(function () {\n    prevWidgetRef.current = widget;\n  }, [widget]);\n  var cleanupTimerRef = useRef(null);\n  var shouldAddWidgetEarly = shouldSsr && !parentIndex.getWidgets().includes(widget); // This effect is responsible for adding, removing, and updating the widget.\n  // We need to support scenarios where the widget is remounted quickly, like in\n  // Strict Mode, so that we don't lose its state, and therefore that we don't\n  // break routing.\n\n  useIsomorphicLayoutEffect(function () {\n    var previousWidget = prevWidgetRef.current;\n\n    function cleanup() {\n      parentIndex.removeWidgets([previousWidget]);\n    } // Scenario 1: the widget is added for the first time.\n\n\n    if (cleanupTimerRef.current === null) {\n      if (!shouldAddWidgetEarly) {\n        parentIndex.addWidgets([widget]);\n      }\n    } // Scenario 2: the widget is rerendered or updated.\n    else {\n      // We cancel the original effect cleanup because it may not be necessary if\n      // props haven't changed. (We manually call it if it is below.)\n      clearTimeout(cleanupTimerRef.current); // Warning: if an unstable function prop is provided, `dequal` is not able\n      // to keep its reference and therefore will consider that props did change.\n      // This could unsollicitely remove/add the widget, therefore forget its state,\n      // and could be a source of confusion.\n      // If users face this issue, we should advise them to provide stable function\n      // references.\n\n      var arePropsEqual = dequal(props, prevPropsRef.current); // If props did change, then we execute the cleanup function instantly\n      // and then add the widget back. This lets us add the widget without\n      // waiting for the scheduled cleanup function to finish (that we canceled\n      // above).\n\n      if (!arePropsEqual) {\n        cleanup();\n        parentIndex.addWidgets([widget]);\n      }\n    }\n\n    return function () {\n      // We don't remove the widget right away, but rather schedule it so that\n      // we're able to cancel it in the next effect.\n      cleanupTimerRef.current = setTimeout(cleanup);\n    };\n  }, [parentIndex, widget, shouldAddWidgetEarly]);\n\n  if (shouldAddWidgetEarly) {\n    parentIndex.addWidgets([widget]);\n  }\n}","map":{"version":3,"names":["useEffect","useRef","dequal","useIsomorphicLayoutEffect","useWidget","_ref","widget","parentIndex","props","shouldSsr","prevPropsRef","current","prevWidgetRef","cleanupTimerRef","shouldAddWidgetEarly","getWidgets","includes","previousWidget","cleanup","removeWidgets","addWidgets","clearTimeout","arePropsEqual","setTimeout"],"sources":["/Users/christoalex/Algolia/my-app/node_modules/react-instantsearch-hooks/dist/es/lib/useWidget.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { dequal } from \"./dequal.js\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect.js\";\nexport function useWidget(_ref) {\n  var widget = _ref.widget,\n      parentIndex = _ref.parentIndex,\n      props = _ref.props,\n      shouldSsr = _ref.shouldSsr;\n  var prevPropsRef = useRef(props);\n  useEffect(function () {\n    prevPropsRef.current = props;\n  }, [props]);\n  var prevWidgetRef = useRef(widget);\n  useEffect(function () {\n    prevWidgetRef.current = widget;\n  }, [widget]);\n  var cleanupTimerRef = useRef(null);\n  var shouldAddWidgetEarly = shouldSsr && !parentIndex.getWidgets().includes(widget); // This effect is responsible for adding, removing, and updating the widget.\n  // We need to support scenarios where the widget is remounted quickly, like in\n  // Strict Mode, so that we don't lose its state, and therefore that we don't\n  // break routing.\n\n  useIsomorphicLayoutEffect(function () {\n    var previousWidget = prevWidgetRef.current;\n\n    function cleanup() {\n      parentIndex.removeWidgets([previousWidget]);\n    } // Scenario 1: the widget is added for the first time.\n\n\n    if (cleanupTimerRef.current === null) {\n      if (!shouldAddWidgetEarly) {\n        parentIndex.addWidgets([widget]);\n      }\n    } // Scenario 2: the widget is rerendered or updated.\n    else {\n      // We cancel the original effect cleanup because it may not be necessary if\n      // props haven't changed. (We manually call it if it is below.)\n      clearTimeout(cleanupTimerRef.current); // Warning: if an unstable function prop is provided, `dequal` is not able\n      // to keep its reference and therefore will consider that props did change.\n      // This could unsollicitely remove/add the widget, therefore forget its state,\n      // and could be a source of confusion.\n      // If users face this issue, we should advise them to provide stable function\n      // references.\n\n      var arePropsEqual = dequal(props, prevPropsRef.current); // If props did change, then we execute the cleanup function instantly\n      // and then add the widget back. This lets us add the widget without\n      // waiting for the scheduled cleanup function to finish (that we canceled\n      // above).\n\n      if (!arePropsEqual) {\n        cleanup();\n        parentIndex.addWidgets([widget]);\n      }\n    }\n\n    return function () {\n      // We don't remove the widget right away, but rather schedule it so that\n      // we're able to cancel it in the next effect.\n      cleanupTimerRef.current = setTimeout(cleanup);\n    };\n  }, [parentIndex, widget, shouldAddWidgetEarly]);\n\n  if (shouldAddWidgetEarly) {\n    parentIndex.addWidgets([widget]);\n  }\n}"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,yBAAT,QAA0C,gCAA1C;AACA,OAAO,SAASC,SAAT,CAAmBC,IAAnB,EAAyB;EAC9B,IAAIC,MAAM,GAAGD,IAAI,CAACC,MAAlB;EAAA,IACIC,WAAW,GAAGF,IAAI,CAACE,WADvB;EAAA,IAEIC,KAAK,GAAGH,IAAI,CAACG,KAFjB;EAAA,IAGIC,SAAS,GAAGJ,IAAI,CAACI,SAHrB;EAIA,IAAIC,YAAY,GAAGT,MAAM,CAACO,KAAD,CAAzB;EACAR,SAAS,CAAC,YAAY;IACpBU,YAAY,CAACC,OAAb,GAAuBH,KAAvB;EACD,CAFQ,EAEN,CAACA,KAAD,CAFM,CAAT;EAGA,IAAII,aAAa,GAAGX,MAAM,CAACK,MAAD,CAA1B;EACAN,SAAS,CAAC,YAAY;IACpBY,aAAa,CAACD,OAAd,GAAwBL,MAAxB;EACD,CAFQ,EAEN,CAACA,MAAD,CAFM,CAAT;EAGA,IAAIO,eAAe,GAAGZ,MAAM,CAAC,IAAD,CAA5B;EACA,IAAIa,oBAAoB,GAAGL,SAAS,IAAI,CAACF,WAAW,CAACQ,UAAZ,GAAyBC,QAAzB,CAAkCV,MAAlC,CAAzC,CAd8B,CAcsD;EACpF;EACA;EACA;;EAEAH,yBAAyB,CAAC,YAAY;IACpC,IAAIc,cAAc,GAAGL,aAAa,CAACD,OAAnC;;IAEA,SAASO,OAAT,GAAmB;MACjBX,WAAW,CAACY,aAAZ,CAA0B,CAACF,cAAD,CAA1B;IACD,CALmC,CAKlC;;;IAGF,IAAIJ,eAAe,CAACF,OAAhB,KAA4B,IAAhC,EAAsC;MACpC,IAAI,CAACG,oBAAL,EAA2B;QACzBP,WAAW,CAACa,UAAZ,CAAuB,CAACd,MAAD,CAAvB;MACD;IACF,CAJD,CAIE;IAJF,KAKK;MACH;MACA;MACAe,YAAY,CAACR,eAAe,CAACF,OAAjB,CAAZ,CAHG,CAGoC;MACvC;MACA;MACA;MACA;MACA;;MAEA,IAAIW,aAAa,GAAGpB,MAAM,CAACM,KAAD,EAAQE,YAAY,CAACC,OAArB,CAA1B,CAVG,CAUsD;MACzD;MACA;MACA;;MAEA,IAAI,CAACW,aAAL,EAAoB;QAClBJ,OAAO;QACPX,WAAW,CAACa,UAAZ,CAAuB,CAACd,MAAD,CAAvB;MACD;IACF;;IAED,OAAO,YAAY;MACjB;MACA;MACAO,eAAe,CAACF,OAAhB,GAA0BY,UAAU,CAACL,OAAD,CAApC;IACD,CAJD;EAKD,CAvCwB,EAuCtB,CAACX,WAAD,EAAcD,MAAd,EAAsBQ,oBAAtB,CAvCsB,CAAzB;;EAyCA,IAAIA,oBAAJ,EAA0B;IACxBP,WAAW,CAACa,UAAZ,CAAuB,CAACd,MAAD,CAAvB;EACD;AACF"},"metadata":{},"sourceType":"module"}